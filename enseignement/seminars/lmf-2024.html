<!doctype html>
<html>

<head>
	<meta charset="utf-8">

	<title>A floating-point numbers theory for Event-B - LMF 2024</title>

	<meta name="description" content="A floating-point numbers theory for Event-B - LMF 2024">
	<meta name="author" content="Idir AIT SADOUNE">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="../reveal-js-framework/dist/reset.css">
	<link rel="stylesheet" href="../reveal-js-framework/dist/reveal.css">
	<link rel="stylesheet" href="../reveal-js-framework/dist/theme/white.css" id="theme">
	<link rel="stylesheet" href="../resources/css/presentation-theme.css">
	<!--<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />-->
	<link rel="stylesheet" href="../../CSS/font-awesome-4.7.0/css/font-awesome.min.css" />

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="../resources/css/event-b-theme.css">

	<link rel="icon" href="../resources/img/favicon.ico" />
</head>

<body>
	<img id="logo" src="./img/lmf.png" alt="">
	<div class="reveal">
		<div class="slides">
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out" data-background="#fff">
	
	<div class="header-logo">
		<div class="left-logo">
			<a href="https://lmf.cnrs.fr/" target="_blank">
				<img  src="../resources/img/logo-aff.png" alt="">
			</a>
		</div>
		<div class="right-logo">
			<a href="https://lmf.cnrs.fr/" target="_blank">
				<img src="./img/lmf.png" alt="">
			</a>
		</div>
	</div>
	
	<div class="slide-content">
		<h2>A floating-point numbers theory <br>for Event-B</h2>
	</div>

	<div class="description" >
		<span class="description-item"><span class="fa fa-graduation-cap">&#160;</span>The LMF Lab Seminar</span><br>
		<span class="description-item"><span class="fa fa-university">&#160;</span>Domaine Saint Paul, Saint-Rémy-lès-Chevreuse - June 13-14, 2024</span>
	</div>

	<div class="hero-card-id">
		<a href="https://wdi.centralesupelec.fr/aitsadoune/" target="_blank">
			<img src="../resources/img/idir.png" class="hero-user">
		</a>
		<div class="hero-desc">
			<a href="https://wdi.centralesupelec.fr/aitsadoune/" target="_blank">
				<span class="hero-name"><strong>Idir AIT SADOUNE </strong></span>
			</a>
			<br>
			<a href="mailto:idiraitsadoune@lmf.cnrs.fr" target="_blank">
				<span class="hero-email">idiraitsadoune@lmf.cnrs.fr</span>
			</a>
		</div>
	</div>
<!-- What I want to say. -->
<aside class="notes">
	Hello everybody... <br><br>
	
	In this talk, I present my work about extending the Event-B method type-checking system to support floating-point 
	numbers using the Theory plugin.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section id="plan">
<!-- What I want to say. -->
<aside class="notes">
	In this presentation, I will follow the following outline.<br><br>

	I start by presenting the main concepts of the Event-B formal method and give an overview of the Theory plugin.<br><br>
	
	Then, I will give an example to illustrate why there is a need to use floating-point arithmetic.<br><br>
	
	After this, I will detail the proposed approach and show how the proposed theories improve the motivating example.<br><br>
	
	At the end of my presentation, I will give a conclusion and some future work.<br><br>
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section id="ch1" name="The context of the work">
<!-- What I want to say. -->
<aside class="notes">
	Let's start by presenting the main concepts of the Event-B method. 
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>The Event-B method</h2>

	<img src="./img/Event-B-book.jpg" style="position: absolute; bottom:0px; right:160px;">
	
	<ul style="display: block;">
		<li>The <b>Event-B method</b> is an evolution of the <i>classical</i>
				<b>B method</b>.
			<ul><li>modeling a system by a <i>set of events</i> instead of <i>operations</i>.</li></ul>
		</li>

		<li class="fragment skip">The <b>Event-B method</b> is a <i>formal method</i> based on <br>
			<i>first-order logic</i> and <i>set theory</i>.</li>

		<li class="fragment skip">The <b>Event-B method</b> is based on :
			<ul>
				<li>the notions of <i>pre-conditions</i> and <i>post-conditions</i> (<b>Hoare</b>),</li>
				<li>the <i>weakest pre-condition</i> (<b>Dijkstra</b>),</li>
				<li>and the <i>calculus of substitution</i> (<b>Abrial</b>).</li>
			</ul>
		</li>
	</ul>
<!-- What I want to say. -->
<aside class="notes">
	The Event-B formal method is an evolution of the classical B method. It's dedicated to formalising reactive 
	systems and allows the modelling of a system's behaviour using a set of discrete events instead of operations. <br><br>

	The Event-B method is based on the first-order logic and set theory. <br><br>

	And, in addition to these concepts, the Event-B method uses the notions of pre-conditions and post-conditions 
	of Hoare, the weakest pre-condition of Dijkstra, and the substitution calculus developed by Jean-Raymond Abrial for the classical B method.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Using Event-B method</h2>
	<ul>
		<li>
			The <b>Rodin</b> platform (an <i>Eclipse-based IDE</i>) is intended to support the construction and verification 
			of <b>Event-B models</b>.
		</li>
		<li class="fragment skip">The use of the <b>Event-B method</b> has continued to increase.
			<ul>
				<li>applied to various applications and domains.</li>
				<li>railway, automotive, aeronautics, cybersecurity, nuclear-energy,  ...</li>
			</ul>
		</li>
		<li class="fragment skip">The <b>Event-B method</b> is adapted to analyse <i>discrete systems</i>.
			<ul><li>offers the possibility of modelling <b>discrete behaviors</b>.</li></ul>
		</li>
	</ul>
<!-- What I want to say. -->
<aside class="notes">
	The Rodin platform is the most used IDE to develop with the Event-B method. It offers the possibility to write models, 
	generate proof obligations and prove them.
	<br><br>
	Since its invention, the use of Event-B has continued to increase, and it has been applied to various applications 
	and domains like railway, automotive, aeronautics, cybersecurity, nuclear-energy,  ... 
	<br><br>
	So, the Event-B method is practical and adapted to analyse discrete systems, and its typing system offers 
	the possibility of modelling discrete behaviours.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>The Event-B method</h2>

	<div style="display: flex;">
	<div style="width: 33%;">
<div class="eb-code">
<pre id="eb">
<b>CONTEXT</b> $ctx_1$
<b>EXTENDS</b> $ctx_2$
</pre>
<pre id="eb" class="fragment" data-fragment-index="2">

<b>SETS</b> $s$
<b>CONSTANTS</b> $c$
<b>AXIOMS</b>
	$A(s,c)$
<b>THEOREMS</b>
	$T(s,c)$
</pre>
<pre id="eb">
<b>END</b>
</pre>
</div>
	</div>
	
	<div style="width: 33%;">
<div class="eb-code">
<pre id="eb">
<b>MACHINE</b> $mch_1$
<b>REFINES</b> $mch_2$
<b>SEES</b> $ctx_i$
</pre>
<pre id="eb" class="fragment" data-fragment-index="3">

<b>VARIABLES</b> $v$
<b>INVARIANTS</b>
	$I(s,c,v)$
<b>THEOREMS</b>
	$T(s,c,v)$
<b>EVENTS</b>
	$[events\_list]$
</pre>
<pre id="eb">
<b>END</b>
</pre>
</div>
	</div>
	
	<div style="width: 33%;">
<div class="eb-code fragment" data-fragment-index="4">
<pre id="eb">
$event$ $\mathrel{\widehat=}$
	<i>any</i> $x$
	<i>where</i>
		$G(s,c,v,x)$
	<i>then</i>
		$BA(s,c,v,x,v')$
	<i>end</i>
</pre>
</div>
	</div>
	</div>

		<div class="d-skip">
			<ul id="eb">
				<li class="fragment" data-fragment-index="5">$A(s,c) ~~~\vdash~~~ T(s,c) $</li>
				<li class="fragment" data-fragment-index="5">$A(s,c) \land I(s,c,v) ~~~\vdash~~~ T(s,c,v)$</li>
				<li class="fragment" data-fragment-index="6">$A(s,c) \land I(s,c,v) \land G(s,c,v,x)  ~~~\vdash~~~ \exists v'.BA(s,c,v,x,v')$</li>
				<li class="fragment" data-fragment-index="7">$A(s,c) \land I(s,c,v) \land G(s,c,v,x) \land BA(s,c,v,x,v') ~~~\vdash~~~ I(s,c,v')$</li>
				<li class="fragment" data-fragment-index="7">$...$</li>
			</ul>
		</div>

<!-- What I want to say. -->
<aside class="notes">
	An Event-B model is made of two component types: machines and contexts. <br>
	The machines contain the dynamic parts of the model, formalising a state of a system that evolves thanks to a set of events. <br>
	In contrast, the contexts contain the static parts defined by axiomatisations and theories. <br>
	A machine can refine another machine, and a context can be extended by another context. <br>
	Moreover, a machine can see one or several contexts. <br><br>

	The CONTEXT component contains the following clauses : <br>
	The SETS clause is used to define new types as abstract and enumerated sets. <br>
	The CONSTANTS clause is used to declare the constants used by the model. <br>
	The AXIOMS clause is used to describe, in first-order logic expressions, the properties of the constants defined in the  CONSTANTS  clause. 
	Types and constraints are described in this clause. <br>
	and Finally, The THEOREMS clause is used to define properties that can be deduced from the axioms. <br><br>

	Similarly to contexts, the MACHINE component contains the following clauses: <br>
	The VARIABLES clause is used to describe the model's state variables. <br>
	The INVARIANTS clause is used to formalise, by first-order logic expressions, the properties of the model state.  <br>
	Typing information and functional and safety properties are usually expressed in this clause. These properties need to be preserved by events.<br>
	As for the CONTEXT, the THEOREMS clause is used to define properties that can be deduced from the invariants.<br>
	Finally, the model's behaviour is defined in the EVENTS clause by a set of events that occur in a given model. <br><br>

	In Event-B, an event can be parametrised. An event is characterised by its guard and actions executed when the guard is true. <br>
	Here, the action is expressed by what we call the before-after predicate, which gives us the relation between the current state 
	and the next after executing the event.
	<br><br>
	One of the important concepts when modelling with Event-B is the refinement process. 
	The refinement encodes model decomposition. A system is decomposed into another system with more and more design decisions while 
	moving from an abstract level to a concrete one. <br>
	Since refinement is not used in the proposed approach, I prefer not to give more details about this process. <br><br>


	From a verification point of view, proof obligations are associated with any Event-B model. They define the formal 
	semantics associated with each Event-B component. <br>
	Briefly, I give here a list of the most generated and used PO rules: <br>
	These two POs ensure that the theorems of a context or machine are provable.  <br><br>

	This PO ensures that a non-deterministic action or event is feasible. <br><br>

	and this last PO ensures that each event preserves each invariant in a machine. <br><br>

	There are other rules for generating PO, for example, to prove the correctness of variable construction, 
	the correctness of using operators, the correctness of refinement, ...	
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>The theory plugin</h2>
	<ul>
		<li><b>Theory Plug-in</b> provides capabilities to <i>extend</i> <b>the Event-B mathematical language</b> and <b>
			the Rodin proving infrastructure</b>.</li>

		<li class="fragment skip">An <b>Event-B theory</b> can contain : 
			<ul>
				<li>new datatype definitions,</li>
				<li>new polymorphic operator definitions,</li>
				<li>axiomatic definitions,</li>
				<li>theorems,</li>
				<li>associated rewrite and inference rules.</li>
			</ul>
		</li>

		<li style="font-size: 15px; margin-top: 80px;">
			Michael J. Butler and Issam Maamria. <br> <span style="font-style: italic;">Practical theory extension in Event-B.</span> 
			<a href="https://link.springer.com/chapter/10.1007/978-3-642-39698-4_5" target="_blank">Theories of Programming and Formal Methods. 2013</a>.
		</li>

		<li style="font-size: 15px;">
			Thai Son Hoang, Laurent Voisin, Asieh Salehi, Michael J. Butler, Toby Wilkinson, and Nicolas Beauger. <br>
			<span style="font-style: italic;">Theory plug-in for Rodin 3.x. </span> 
			<a href="https://arxiv.org/abs/1701.08625" target="_blank">CoRR, abs/1701.08625, 2017</a>.
		</li>
	</ul>

	
<!-- What I want to say. -->
<aside class="notes">
	Since The Rodin platform is an Eclipse-based IDE and is extensible by plugins, the Theory plugin was developed by Issam Maamria during his PHD. 
	<br><br>
	This plug-in enables modellers to extend the mathematical modelling notation for Event-B, with accompanying support for reasoning 
	about the extended language. 
	<br><br>
	In other words, the theory plugin extends the Rodin platform by providing a new syntax to define mathematical and prover extensions 
	with the theory component.
	<br><br>
	A theory is used to define new data-types, polymorphic operators, axioms, theorems and associated rewrite and inference rules.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>The Event-B method</h2>

	<div style="display: flex;">
	<div class="fragment" style="width: 33%;">
<div class="eb-code">
<pre id="eb">
<b>THEORY</b> $thy_1$
<b>IMPORT</b> $thy_2$

<b>DATATYPES</b> 
	$DT_1,...,DT_n$
<b>OPERATORS</b> 
	$OP_{11},...,OP_{1n}$
<b>AXIOMATIC DEFINITIONS</b>
	<i>operators</i>
		$OP_{21},...,OP_{2n}$
	<i>axioms</i>
		$A$
<b>THEOREMS</b>
	$T$
<b>PROOF RULES</b>
	$PR$
<b>END</b>
</pre>	
</div>		
	</div>

	<div style="width: 33%;">
<div class="eb-code">
<pre id="eb">
<b>CONTEXT</b> $ctx_1$
<b>EXTENDS</b> $ctx_2$

<b>SETS</b> $s$
<b>CONSTANTS</b> $c$
<b>AXIOMS</b>
	$A(s,c)$
<b>THEOREMS</b>
	$T(s,c)$
</pre>
<pre id="eb">
<b>END</b>
</pre>
</div>
	</div>
	
	<div style="width: 33%;">
<div class="eb-code">
<pre id="eb">
<b>MACHINE</b> $mch_1$
<b>REFINES</b> $mch_2$
<b>SEES</b> $ctx_i$

<b>VARIABLES</b> $v$
<b>INVARIANTS</b>
	$I(s,c,v)$
<b>THEOREMS</b>
	$T(s,c,v)$
<b>EVENTS</b>
	$[events\_list]$
</pre>
<pre id="eb">
<b>END</b>
</pre>
</div>
	</div>
	</div>
<!-- What I want to say. -->
<aside class="notes">
Now, with the Theory component, an Event-B model can be specified using three component types besides Context and Machine.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section id="ch2" name="The motivating example"></section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>A simple example</h2>
		

	<ul>
		<li>System that continuously calculates <b>a moving object's speed</b></li>
	</ul>

	<div class="d-skip">
		<img src="./img/motivating-example.svg" alt="" width="80%">
	</div>
	
<!-- What I want to say. -->
<aside class="notes">
	To illustrate our approach for extending the Event-B core with the floating-point numbers data type, we propose to model a system 
	that continuously calculates a moving object's speed. 
	<br><br>
	As we can see in this picture, in our system, we have two moments that can correspond to two main events : <br>
	In the first moment, we capture the initial information about time and position.<br>
	and In the second moment, we capture new information about the time and the distance travelled.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>A simple example</h2>

	<ul>
		<li>Analysing <b>two functional properties</b>:
			<ul>
				<li class="fragment"><strong>PROP-1</strong> : <b>the speed of the moving object</b> is equal to the <code class="listing">$distance\_travelled$</code> <br>
					divided by the <code class="listing">$measured\_time$</code>  (<code class="listing">$v = d/t$</code>).</li>
				<li class="fragment"><strong>PROP-2</strong> : when the <code class="listing">$distance\_travelled$</code> <i>is strictly positive</i>, the <code class="listing">$speed$</code> <br> 
					of the moving object must also be <i>strictly positive</i>.
					<ul><li> <b>the object moves</b> when its <code class="listing">$speed$</code> is different from zero.</li></ul>
				</li>
			</ul>
		</li>
	</ul>

	<div id="green-block" class="d-skip fragment" style="width: 80%;">
		<b>Objectives</b> $\to$ showing some <b>modelling and verification</b> <b style="color: red;">problems</b> :<br> 
		<ul>
			<li class="fragment">analysing <b>physical phenomena</b>.
				<ul><li>expressions that come from <i>the physics laws</i>.</li></ul>
			</li>
			<li  class="fragment">using <b>integer</b> variables to handle <b>small values</b>.</li>
		</ul>
	</div>
	
<!-- What I want to say. -->
<aside class="notes">
The target Event-B model will formalise two main functional properties: <br>
The first property called -PROP~1- and specifying that the speed of the moving object is equal to the "distance_travelled" divided by the "measured_time",<br>
And the second property called -PROP~2- and specifying that when the "distance_travelled" is strictly positive, the "speed" of the moving object must also 
be strictly positive <br> 
In other words, the object moves when its speed differs from zero. 
<br><br>
The main objective of this example is to show some modelling and verification problems that we can face when we analyse physical phenomena, 
mainly when we use integer variables to handle small values and expressions that come from the physics laws.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>The Event-B model</h2>

	<ul>
		<li>Analysing <b>two functional properties</b>:
			<ul>
				<li><strong>PROP-1</strong> : <b>the speed of the moving object</b> is equal to the <code class="listing">$distance\_travelled$</code> <br>
					divided by the <code class="listing">$measured\_time$</code>  (<code class="listing">$v = d/t$</code>).</li>
				<li><strong>PROP-2</strong> : when the <code class="listing">$distance\_travelled$</code> <i>is strictly positive</i>, the <code class="listing">$speed$</code> <br> 
					of the moving object must also be <i>strictly positive</i>.
					<ul><li> <b>the object moves</b> when its <code class="listing">$speed$</code> is different from zero.</li></ul>
				</li>
			</ul>
		</li>
	</ul>

<div class="eb-code" style="margin-top: 28px; width: 58%;">
<pre id="eb">
<b>MACHINE</b> mch_integer_version
...
<b>INVARIANTS</b>
	<u>@inv1:</u> distance_travelled $\in$ $\mathbb N$
	<u>@inv2:</u> measured_time $\in$ $\mathbb N_1$
	<u>@inv3:</u> speed $\in$ $\mathbb N$
	<u>@inv4:</u> starting_position $\in$ $\mathbb N$
	<u>@inv5:</u> starting_time $\in$ $\mathbb N$
</pre>
<pre id="eb" class="fragment">
	<u>@inv6:</u> speed $=$ distance_travelled $\div$ measured_time <u>// PROP-1</u>
	<u>@inv7:</u> distance_travelled $>$ $0$ $\mathbin\Rightarrow$ speed $>$ $0$ <u>// PROP-2</u>
</pre>
</div>
	
<!-- What I want to say. -->
<aside class="notes">
We define a model that contains the following state variables : <br>
"starting_position" and "starting_time" variables used to capture the starting point information of the moving object. <br>
and, "distance_travelled", "measured_time" and "speed" variables used to formalise the state of the moving object after performing a movement. <br>
<br>
the sixth invariant formalises the PROP 1 of our specification <br>
when the seventh invariant formalises the PROP 2.
</aside>	
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>The Event-B model</h2>
		
<div class="r-stack">				
<div class="eb-code fragment fade-out" style="width: 70%" data-fragment-index="0">
<pre id="eb">
<b>MACHINE</b> mch_integer_version
...
<b>EVENTS</b>
	...
	get_starting_point $\mathrel{\widehat=}$
		<i>any</i> p t 
		<i>where</i>
			<u>@grd1:</u> p $\in$ $\mathbb N_1$
			<u>@grd2:</u> t $\in$ $\mathbb N_1$
		<i>then</i>
			<u>@act1:</u> starting_position $:=$ p
			<u>@act2:</u> starting_time $:=$ t
		<i>end</i>
	...
<b>END</b>
</pre>
</div>
<div class="eb-code fragment" style="width: 70%" data-fragment-index="0">
<pre id="eb" >
<b>MACHINE</b> mch_integer_version
...
<b>EVENTS</b>
	...
	get_speed $\mathrel{\widehat=}$
		<i>any</i> p t 
		<i>where</i>
			<u>@grd1:</u> p $\in$ $\mathbb N_1$ $\land$ p $>$ starting_position
			<u>@grd2:</u> t $\in$ $\mathbb N_1$ $\land$ t $>$ starting_time
		<i>then</i>
			<u>@act1:</u> distance_travelled $:=$ p $-$ starting_position
			<u>@act2:</u> measured_time $:=$ t $-$ starting_time
			<u>@act3:</u> speed $:=$ (p $-$ starting_position) $\div$ (t $-$ starting_time)
		<i>end</i>
<b>END</b>
</pre>
</div>
	</div>

<!-- What I want to say. -->
<aside class="notes">	
The proposed Event-B model contains two main events : <br><br>

The first event, called "get_starting_point", allows the capture of the starting point information 
of the moving object by initialising the "starting_position" and "starting_time" variables. <br><br>

And the second event of the proposed Event-B model, called "get_speed", that captures the new position of the moving 
object and calculates the new values of the "measured_time", "distance_travelled", and "speed" variables. <br>
These new values depend on the initial position stored in the "starting_time" and "starting_position" variables captured 
by the previous event.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>generated and proven POs</h2>

	<img src="./img/fig1.png" height="400px"
		style="float: right; margin-bottom: 10px; margin-left: 10px;">

	<ul style="display: block;">
		<li><b>All POs are green</b> <b style="color: red;">except</b> the one for maintaining <br> the <span style="color: green;">$@inv7$</span> 
			invariant by the <code class="listing">$get\_speed$</code> event.</li>

		<li class="fragment skip">This invariant formalises the <b>PROP 2</b> property.
			<ul><li><b>the object moves</b> (<code class="listing">$distance\_travelled \neq 0$</code>) <br> 
				when <code class="listing">$speed \neq 0$</code>.</li></ul>
		</li>

		<li class="fragment skip">The <code class="listing">$get\_speed$</code> event calculates the new value <br> 
			of <code class="listing">$distance\_travelled$</code>
				that can be <code class="listing">$\lt$</code> the new value <br> 
				of <code class="listing">$measured\_time$</code>.
			<ul id="fleche" class="fragment">
				<li>the new value of <code class="listing">$speed$</code> <br>
					(<code class="listing">$distance\_travelled \div measured\_time$</code>) <br> 
					can be	<code class="listing">$= 0$</code> while <code class="listing">$distance\_travelled \neq 0$</code> 
				</li>
				<li class="fragment">
					<code class="listing">$\div$</code> makes <b>an integer division</b>
				</li>
			</ul>
		</li>
	</ul>

<aside class="notes">	
From the model verification point of view, all the POs are green except the one maintaining the "@inv7" 
invariant by the "get_speed" event. <br><br>

For recall, this invariant formalises the  PROP~2 property of our system, specifying that 
if the value of the "distance_travelled" variable is strictly positive, the "speed" variable must also be strictly positive. <br><br>

However, in the "get_speed" event, the value of the expression "p - starting_position" can be less than 
that of "t - starting_time". <br>
In this case, the new value of the "speed" variable becomes equal to zero while the one of the "distance_travelled" variable is not 
because all variables of our model are integer variables, and the "division" Event-B operator makes an integer division. <br><br>

For these reasons, this PO cannot be proven. 
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Conclusion</h2>

	<div id="alert-block" style="text-align: center; width: 66%;">
		<b>The basic types and operators of the Event-B language <br> are not adapted to our needs</b>  
	</div>

<aside class="notes">
Conceptually, our model correctly specifies our requirements. <br>
but the basic types and operators of the Event-B language are not adapted to our needs and do not allow us 
to verify continuous behaviour requirements and manipulate small and big values simultaneously.
</aside>
</section>	
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section id="ch3" name="The proposed approach">
<aside class="notes">
For these reasons and others, we propose to develop a floating-point numbers theory using the theory plugin 
to extend the Event-B type-checking system with the possibility of handling floating-point numbers.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>floating-point numbers</h2>

	<div>
		$$
			x = 3.14159265359 = 
			\underset{\text{significand}}{\underbrace{314159265359}} \times 
			\underset{\text{base}}{\underbrace{10}}^{\overset{\text{exponent}}{\overbrace{-11}}}
		$$
	</div>

	<div id="default-block" class="fragment skip" style="width: 76%;">
		<b>We have chosen that the base always equals ten in our models.</b>
		$$
			x = s(x) \times 10^{e(x)}
		$$
		<ul class="fragment">
			<li>The proposed theory <b>does not model limited precision</b>.</li>
			<li>The <b>operators</b> defined in the theory involve <b>no precision loss</b>.</li>
		</ul>
	</div>
<aside class="notes">
As known, the floating point is the most used method for representing and approximating real numbers in computer-based arithmetic. <br>
Therefore, we propose to represent real numbers by using floating-point arithmetic. <br>
This approach represents floating-point numbers using an integer called the "significand", scaled by an integer "exponent"
of a fixed "base". <br><br>

We have chosen that the "base" always equals ten in our models. 
<br><br>

The proposed theory does not model floating point numbers with limited precision. 
This implies that the operators defined in the theory involve no precision loss. We will discuss the impact of this choice later.
</aside>	
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>The proposed approach</h2>
	
	<ul>
		<li>
			To allow the <b>Event-B language</b> to <i>embed</i> this <b>FP representation</b>, <br>
			we need to define two theories:
			<ol>
				<li class="fragment skip">the first theory formalises <b>the power operator</b>. 
					<ul id="ko">
						<li class="fragment"><i><span class="listing">^</span> operator</i> is <b style="color: red;">not implemented</b> 
							in the provers besides <span class="listing">^0</span> and <span class="listing">^1</span>.</li>
					</ul>
				</li>
				<li class="fragment skip">the second theory formalises <b>floating-point numbers</b> by specifying: 
					<ul id="fleche">
						<li>the corresponding <i>data type</i>,</li>
						<li>the supported <i>arithmetic operators</i>,</li>
						<li>some <i>axioms</i> and <i>theorems</i> that characterize the proposed modelling.</li>
					</ul>
				</li>
			</ol>
		</li>
	</ul>
		
	
<aside class="notes">
To allow the Event-B language to embed this floating-point representation, 
we need to define two theories: <br><br>

the first theory formalises the power operator that isn't included in the Event-B language 
(the "^" caret operator available in Event-B language is not implemented in the provers 
supported by the Rodin platform, besides power 0 and 1), <br><br>

and the second theory formalises floating-point numbers by specifying the corresponding data type, the supported arithmetic operators, 
and some axioms and theorems that characterise the proposed modelling.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>The power operator</h2>

	<div class="eb-code" style="width: 72%;">
<pre id="eb">
<b>THEORY</b> thy_power_operator

<b>AXIOMATIC DEFINITIONS</b>
	<i>operators</i>
		pow(x $\in$ $\mathbb Z$, n $\in$ $\mathbb N$) : $\mathbb Z$ <strong>INFIX</strong> <u>// x pow n $=$ $x^n$</u>
		<i>wd condition</i> : $\neg$ (x $=$ 0 $\land$ n $=$ 0) <u>// $0^0$ is not defined</u>
</pre>
<pre id="eb" class="fragment">

	<i>axioms</i>
		<u>@axm1:</u> $\forall$ n $\cdot$ n $\in \mathbb N_1$ $\mathbin\Rightarrow$ 0 pow n $=$ 0
		<u>@axm2:</u> $\forall$ x $\cdot$ x $\in \mathbb Z$ $\land$ x $\neq$ 0 $\mathbin\Rightarrow$ x pow 0 $=$ 1
		<u>@axm3:</u> $\forall$ x,n $\cdot$ x $\in \mathbb Z$ $\land$ x $\neq$ 0 $\land$ n $\in \mathbb N_1$ $\mathbin\Rightarrow$ x pow n $=$ x $\times$ (x pow (n $-$ 1))
		...
</pre>
<pre id="eb" class="fragment">

<b>THEOREMS</b>
	<u>@thm1:</u> $\forall$ x,n,m $\cdot$ $...$ $\mathbin\Rightarrow$ x pow (n $+$ m) $=$ (x pow n) $\times$ (x pow m)
	<u>@thm2:</u> $\forall$ x,n,m $\cdot$ $...$ $\mathbin\Rightarrow$ (x pow n) pow m $=$ x pow (n $\times$ m)
	<u>@thm3:</u> $\forall$ x,y,n $\cdot$ $...$ $\mathbin\Rightarrow$ (x $\times$ y) pow n $=$ (x pow n) $\times$ (y pow n)
	...
</pre>
<pre id="eb">

<b>END</b>
</pre>
	</div>
	
<aside class="notes">
In this theory, we have defined a power operator that uses natural exponents. The power operation with natural 
exponents may be expressed with multiplication operations. <br><br>

The definition of exponentiation as an iterated multiplication can be formalized using induction. 
The base case is "x^0=1" and the recurrence is "x^n = x * x^(n-1)".  <br><br>
	
For the case "0^0", in contexts where only natural powers are considered, 0 to the power 0 is undefined 
as specified in the  well definedness condition of the "pow" operator.<br><br>

The proposed theory also contains some proven theorems formalising some exponent rules like the product rule, 
the power rule, and the multiplying exponents rule.
</aside>	
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Some remarks</h2>
	<ul>
		<li>By using this theory, it <b>becomes possible to prove</b>, for example, that <br>
			<span class="listing">5 pow 3 = 125</span></li>

		<li class="fragment skip"><b>The proofs</b> of all theorems were made by <b>induction</b><br>
			(following the rules defined by <strong>Cervelle and Gervais - ABZ 2023</strong>).</li>

		<li class="fragment skip">We have chosen to define the <span class="listing">pow</span> operator in a <b>single theory</b><br>
			to offer the possibility of <b>reusing it</b> in other <b>Event-B</b> <i>developments</i>.</li>

		
		<li style="font-size: 15px; margin-top: 100px;">
			Julien Cervelle and Frédéric Gervais.<br>
			<span style="font-style: italic;">Introducing Inductive Construction in B with the Theory Plugin</span>. 
			<a href="https://link.springer.com/chapter/10.1007/978-3-031-33163-3_4" target="_blank">ABZ, 2023</a>.
		</li>
	</ul>
<aside class="notes">
	Now, By using this theory, it becomes possible to prove, for example, that "5 pow 3 = 125". <br><br>

	The proofs of all theorems were made by induction following the rules defined by Cervelle and Gervais in the ABZ 2023 conference. <br><br> 
	
	Notice that we have chosen to define the "pow" operator in a single theory to offer the possibility of reusing this operator in other Event-B 
	components using the theory path mechanism available in the theory plugin.
</aside>	
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>The floating-point numbers theory</h2>

	<div class="eb-code">
<pre id="eb">
<b>THEORY</b> thy_floating_point_numbers

<b>DATATYPES</b>
	FLOAT_Type $\mathrel{\widehat=}$ NEW_FLOAT(s $\in$ $\mathbb Z$, e $\in$ $\mathbb Z$) <u>// $x = s(x) \times 10^{e(x)}$</u>
</pre>
<pre id="eb" class="fragment">

<b>OPERATORS</b>
	F0 $\mathrel{\widehat=}$ NEW_FLOAT(0,0)  <u>// $0 = 0 \times 10^0$</u>
	F1 $\mathrel{\widehat=}$ NEW_FLOAT(1,0)  <u>// $1 = 1 \times 10^0$</u>
</pre>
<pre id="eb" class="fragment">
	FLOAT1_Type $\mathrel{\widehat=}$ { x $\cdot$ x $\in$ FLOAT_Type $\land$ s(x) $\neq$ 0 | x }
</pre>
<pre id="eb" class="fragment">
	FLOAT(x $\in$ $\mathbb Z$) $\mathrel{\widehat=}$ NEW_FLOAT(x,0)  <u>// $x = x \times 10^0$</u>
</pre>
<pre id="eb" class="fragment">

	l_shift(x $\in$ FLOAT_Type, offset $\in$ $\mathbb N$) $\mathrel{\widehat=}$ NEW_FLOAT(s(x) $\times$ (10 pow offset), e(x) $-$ offset)
</pre>
<pre id="eb" class="fragment">

	eq(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$
		s(l_shift(x, e(x) $-$ min({e(x),e(y)}))) $=$ s(l_shift(y, e(y) $-$ min({e(x),e(y)})))
</pre>
<pre id="eb" class="fragment">
	gt(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$ ...
	geq(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$ ...
	lt(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$ ...
	leq(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$ ...
	...
</pre>
<pre id="eb">

<b>END</b>
</pre>
	</div>

<aside class="notes">
Let us describe the floating-point numbers theory. <br><br>

The proposed theory formalizes a floating-point number by defining a new data type called FLOAT_Type. 
This new data type provides the NEW_FLOAT 
constructor that allows creating a floating-point number by giving the "significand" part "s" and the "exponent" part "e".
<br><br>

Using the NEW_FLOAT constructor, we have defined constants like F0 for the value 0 
and F1 for the value 1.<br><br>

We have defined a set FLOAT1_Type containing all float numbers that differ from zero.  <br><br>

This theory also provides the FLOAT operator that translates any Event-B integer value into the FLOAT_Type. <br><br>

The floating-point theory redefines all essential arithmetic operators, essentially comparison and calculation operators. <br>
The operator we have to define to overload 
all arithmetic operators is the left shift operator. This operator uses a positive offset to perform
a left shift by multiplying the significand part by a power of ten corresponding to an offset.<br><br>

So, to compare two numbers, we left-shift the number containing the biggest exponent to have the same exponent 
as the other number. Then, when two numbers have the same exponents, 
it's possible to compare them only by comparing their significand parts. <br><br>

By this way, we have defined the operators (=, >, >=, <, <=) comparing two floating-point numbers. 
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>The floating-point numbers theory</h2>

	<div class="eb-code">
<pre id="eb">
<b>THEORY</b> thy_floating_point_numbers
...
<b>OPERATORS</b>
	...
	plus(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$
		NEW_FLOAT(s(l_shift(x,e(x) $-$ min({e(x),e(y)}))) $+$ s(l_shift(y,e(y) $-$ min({e(x),e(y)}))), 
							min({e(x),e(y)}))
</pre>
<pre id="eb" class="fragment">
	minus(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$ ...
	neg(x $\in$ FLOAT_Type) $\mathrel{\widehat=}$ ...
</pre>
<pre id="eb" class="fragment">

	mult(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) <strong>INFIX</strong> $\mathrel{\widehat=}$ NEW_FLOAT(s(x) $\times$ s(y) , e(x) $+$ e(y))
</pre>
<pre id="eb" class="fragment">
	f_pow(x $\in$ FLOAT_Type, n $\in$ $\mathbb N$) <strong>INFIX</strong> $\mathrel{\widehat=}$ NEW_FLOAT(s(x) pow n, e(x) $\times$ n)
</pre>
<pre id="eb" class="fragment">
	floor(x $\in$ FLOAT_Type) $\mathrel{\widehat=}$ ...
	ceiling(x $\in$ FLOAT_Type) $\mathrel{\widehat=}$ ...
	integer(x $\in$ FLOAT_Type) $\mathrel{\widehat=}$ ...
	frac(x $\in$ FLOAT_Type) $\mathrel{\widehat=}$ ...
	...
</pre>
<pre id="eb">

<b>END</b>	
</pre>
	</div>

<aside class="notes">
Using the same reasoning for the comparison, we have generalised the idea to the addition and substraction operators. 
A left shift of one of the two operands is necessary to perform the addition and substraction operations. <br><br>

However, the multiplication operation is performed by multiplying the significand parts of the two operands, and the resulting 
exponent is obtained by adding the exponent parts of the two operands. <br><br> 

Also, the "f_pow" operator generalises the defined "pow" operator for the floating-point numbers.  <br><br> 

Finally, the floating-point data type is often used in physics laws and scientific calculations. 
So, functions calculating the integer part, fractional part, the floor function and the ceiling function are very useful.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>The case of <code class="listing">inv</code> and <code class="listing">div</code> operators</h2>
	
	<ul>
		<li>The proposed theory involves <b>no precision loss</b>  for <code class="listing">plus</code>
			and <code class="listing">mult</code> operators.</li>
		<li class="fragment skip">The <b>division</b> sometimes <b>induces a precision loss</b>.
			<ul id="ko">
				<li><strong>ex.</strong> we cannot precisely represent the result of $1/3$ or $2/3$</li>
			</ul>
		</li>
		<li class="fragment skip">For the case of <code class="listing">inv</code> and <code class="listing">div</code> operators,
			we have defined <br> <b>the well-definedness conditions</b>. 
			<ul>
				<li class="fragment">
					To calculate <code class="listing">$inv(x)$</code>, we must find a <code class="listing">$z$</code>, 
					with <code class="listing">$10^n = z \times s(x)$</code>.
					<ul id="ok">
						<li class="fragment">$inv(2.5) = 1/2.5 = 0.4 = 4 \times$ $10^{-1}$ (<b style="color: green;">$z = 4$</b> because $100 = 4 \times 25$)</li>	
					</ul>
					<ul id="ko">
						<li class="fragment">$inv(3) = 1/3 = 0.3333...$ (<b style="color: red;">$z$ does not exist</b>)</li>
					</ul>
				</li>
				<li class="fragment skip">
					To calculate <code class="listing">$x$ $div$ $y$</code>, we must find a <code class="listing">$z$</code>, 
					with <code class="listing">$10^n \times s(x) = z \times s(y)$</code>.
					<ul id="ok">
						<li>$2$ $div$ $5 = 2/5 = 0.4 = 4 \times$ $10^{-1}$ (<b style="color: green;">$z = 4$</b> because $10 \times 2 = 4 \times 5$)</li>
					</ul>
					<ul id="ko">
						<li>$2$ $div$ $3 = 2/3 = 0.6666....$ (<b style="color: red;">$z$ does not exist</b>)</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>

<aside class="notes">
While the proposed theory involves no precision loss for multiplication and addition, division sometimes induces a precision loss. 
For example, we cannot precisely represent the result of 1/3 or 2/3. <br><br>

That is why, for the case of the division and inverse operators, we have first defined the well-definedness conditions. <br><br>
To calculate the inverse of x, we must find a z, which we multiply by the significand part of x to obtain a power of ten. 
Here, the value of z corresponds to the significand part of the result of calculating the inverse of x. <br><br>

For example, to calculate the inverse of 2.5, 4 corresponds to z, which does not exist for the inverse of 3. <br><br>

The same reasoning is done for the division operator.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-auto-animate data-transition="fade-in fade-out">
	<h2>The case of <code class="listing">inv</code> and <code class="listing">div</code> operators</h2>

<div class="eb-code">
<pre id="eb">
<b>THEORY</b> thy_floating_point_numbers
...
<b>OPERATORS</b>
	...
	inv_WD(a $\in$ FLOAT1_Type) $\mathrel{\widehat=}$ 
		$\exists$ n,z $\cdot$ n $\in \mathbb N$ $\land$ z $\in \mathbb Z$ $\land$ 10 pow n $=$ s(a) $\times$ z
	div_WD(a $\in$ FLOAT_Type, b $\in$ FLOAT1_Type) $\mathrel{\widehat=}$
		$\exists$ n,z $\cdot$ n $\in \mathbb N$ $\land$ z $\in \mathbb Z$ $\land$ s(a) $\times$ (10 pow n) $=$ s(b) $\times$ z
	...
</pre>
<div class="r-stack">
<pre id="eb" class="fragment fade-in-then-out">
<b>AXIOMATIC DEFINITIONS</b>
	<i>operators</i>
		inv(x $\in$ FLOAT_Type) : FLOAT1_Type
		<i>wd condition</i> : inv_WD(x)

	<i>axioms</i>
		<u>axm1:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ ((x mult y) $=$ F1 $\mathbin\Leftrightarrow$ inv(x) $=$ y))
		<u>axm2:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ ((x mult y) eq F1 $\mathbin\Leftrightarrow$ inv(x) eq y))
		...
</pre>
<pre id="eb" class="fragment fade-in">
<b>AXIOMATIC DEFINITIONS</b>
	...
	<i>operators</i>
		div(x $\in$ FLOAT_Type, y $\in$ FLOAT_Type) : FLOAT_Type <strong>INFIX</strong>
		<i>wd condition</i> : div_WD(x)

	<i>axioms</i>
		<u>axm1:</u> $\forall$ x,y,z $\cdot$ ($...$ $\mathbin\Rightarrow$ ((y mult z) $=$ x $\mathbin\Leftrightarrow$ (x div y) $=$ z))
		<u>axm2:</u> $\forall$ x,y,z $\cdot$ ($...$ $\mathbin\Rightarrow$ ((y mult z) eq x $\mathbin\Leftrightarrow$ (x div y) eq z))
		<u>axm3:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ x mult inv(y) $=$ x div y)
		...	
</pre>
</div>
<pre id="eb">

<b>END</b>
</pre>
</div>

<aside class="notes">
	These two well-definedness conditions are defined by the "inv_WD" and "div_WD" operators. <br><br>

	So, We use axiomatic definitions to formalise "inverse" and "division" operators. Both 
	are invocable if their well-definedness conditions are true <br><br>
	
	The inverse of x is y if and only if y is the number we multiply by x to obtain F1. We define the case of exact equality and also 
	the case of equality after performing a left-shift operation.<br><br>

	Also, the result of dividing x by y is z, if and only if z is the number we multiply by y to obtain x. We have the case of exact equality 
	and also the case of equality after performing a left-shift operation. We have also defined the axiom defining the relation between
	the inverse operator and the division operator. 
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>The floating-point numbers theory</h2>

<div class="eb-code">
<pre id="eb">
<b>THEORY</b> thy_floating_point_numbers
...
<b>THEOREMS</b>
	<u>@thm1:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ x eq y $\mathbin\Leftrightarrow$ y eq x)
	<u>@thm2:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x geq x $\land$ x leq x)
	<u>@thm3:</u> $\forall$ x,y $\cdot$ ($...$ x leq y $\land$ y leq x $\mathbin\Rightarrow$ x eq y)
	<u>@thm4:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ x leq y $\lor$ y leq x)
	<u>@thm5:</u> $\forall$ x,y,z $\cdot$ ($...$ x leq y $\land$ y leq z $\mathbin\Rightarrow$ x leq z)
	<u>@thm6:</u> $\forall$ x,y,z $\cdot$ ($...$ x leq y $\mathbin\Rightarrow$ (x plus z) leq (y plus z))
	<u>@thm7:</u> $\forall$ x,y,z $\cdot$ ($...$ x leq y $\mathbin\Rightarrow$ (x mult z) leq (y mult z))
	<u>@thm8:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x plus F0 eq x)
	<u>@thm9:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ x plus y $=$ y plus x)
	<u>@thm10:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ x plus neg(y) $=$ y minus x)	
	<u>@thm11:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x minus F0 eq x)
	<u>@thm12:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x minus x eq F0)
	<u>@thm13:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x mult F0 eq F0)
	<u>@thm14:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x mult F1 $=$ x)
	<u>@thm15:</u> $\forall$ x,y $\cdot$ ($...$ $\mathbin\Rightarrow$ x mult y $=$ y mult x)
	<u>@thm16:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ inv(x) $=$ F1 div x)
	<u>@thm17:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x div F1 $=$ x)
	<u>@thm18:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x div x $=$ F1)
	<u>@thm19:</u> $\forall$ x $\cdot$ ($...$ $\mathbin\Rightarrow$ x mult inv(x) $=$ F1)
	...	
<b>END</b>
</pre>	
</div>
	
<aside class="notes">
The last part of the proposed theory contains a set of theorems that we have proven, 
and that correspond to properties of arithmetic operators. 
<br><br>
For example: equality, addition, and multiplication 
commutativity, 
<br><br>
the order is total, reflexive, anti-symmetric and transitive, 
<br><br>
addition and multiplication have an inverse, ...
<br><br>
and others theorems combining the comparison operators and the arithmetic operators. 
</aside>
	
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Some remarks</h2>
	<ul>
		<li>
			Due to our choice to formalise <b>unlimited precision FP</b> numbers, some<br>
			 <i>properties</i> that are <b>not true</b> in the FP numbers world <i>can be deduced</i>.
			<ul>
				<li>the associativity of addition and multiplication, for example</li>
			</ul>
		</li>
		<li class="fragment skip">
			If this theory <i>is refined</i> (towards the <b>IEEE Standard 754</b>, for example), <br>
			the developer must <b style="color:red">pay attention</b> to this point.
		</li>
	</ul>

<aside class="notes">
Due to our choice to formalise unlimited precision floating-point numbers, 
some properties,that are not true in the floating-point numbers world, can be deduced from our definitions. <br><br>
For example, the associativity of addition and multiplication, for example.  <br><br>

When this theory is refined towards any implementation (the IEEE Standard 754, for example), the developer must pay attention to this point.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section id="ch4" name="Revisiting the motivating example">
	<aside class="notes">
		So, now I will show how our moving object model is updated with the new developed theory. 
	</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Natural variables</h2>

	<p>
		All <span class="listing">NATURAL</span> variables are typed by 
			<span class="listing">PFLOAT_Type</span> set <br> containing <i>positive floating-point numbers</i>.
	</p>

<div class="eb-code" style="width: 60%;">
<pre id="eb">
<b>THEORY</b> thy_floating_point_numbers
	...
	PFLOAT_Type = { x $\cdot$ x $\in$ FLOAT_Type $\land$ s(x) $\geq$ 0 | x }
	PFLOAT1_Type = { x $\cdot$ x $\in$ FLOAT_Type $\land$ s(x) $>$ 0 | x }
	...
<b>END</b>
</pre>
</div>

<aside class="notes">
	Since all state variables of the initial model are Natural integers, 
	we have defined a set called PFLOAT_Type containing all positive floating-point numbers. <br><br>
	We have also defined a set called PFLOAT1_Type containing strictly positive floating-point numbers.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Revisiting our example I</h2>

<div class="r-stack">

<div class="eb-code fragment fade-out" data-fragment-index="0">
<pre id="eb">
<b>MACHINE</b> mch_integer_version 
...
<b>INVARIANTS</b>
	<u>@inv1:</u> distance_travelled $\in$ $\mathbb N$
	<u>@inv2:</u> measured_time $\in$ $\mathbb N_1$
	<u>@inv3:</u> speed $\in$ $\mathbb N$  
	<u>@inv4:</u> starting_position $\in$ $\mathbb N$ 
	<u>@inv5:</u> starting_time $\in$ $\mathbb N$ 
	<u>@inv6:</u> speed = distance_travelled $\div$ measured_time 
	<u>@inv7:</u> distance_travelled $>$ $0$ $\mathbin\Rightarrow$ speed $>$ $0$
...
<b>END</b>
</pre>
</div>

<div class="eb-code fragment current-visible" data-fragment-index="0">
<pre id="eb" >
<b>MACHINE</b> mch_floating_point_version 
...
<b>INVARIANTS</b>
	<u>@inv1:</u> distance_travelled $\in$ PFLOAT_Type
	<u>@inv2:</u> measured_time $\in$ PFLOAT1_Type 
	<u>@inv3:</u> speed $\in$ PFLOAT_Type 
	<u>@inv4:</u> starting_position $\in$ PFLOAT_Type 
	<u>@inv5:</u> starting_time $\in$ PFLOAT_Type
	<u>@inv7:</u> speed eq distance_travelled div measured_time
	<u>@inv8:</u> distance_travelled gt F0 $\mathbin\Rightarrow$ speed gt F0
...
<b>END</b>
</pre>
</div>

<div class="eb-code fragment">
<pre id="eb">
<b>MACHINE</b> mch_floating_point_version 
...
<b>INVARIANTS</b>
	<u>@inv1:</u> distance_travelled $\in$ PFLOAT_Type
	<u>@inv2:</u> measured_time $\in$ PFLOAT1_Type 
	<u>@inv3:</u> speed $\in$ PFLOAT_Type 
	<u>@inv4:</u> starting_position $\in$ PFLOAT_Type 
	<u>@inv5:</u> starting_time $\in$ PFLOAT_Type
	<span style="color: orangered;">@inv6: div_WD(distance_travelled, measured_time)</span>
	<u>@inv7:</u> speed eq distance_travelled div measured_time
	<u>@inv8:</u> distance_travelled gt F0 $\mathbin\Rightarrow$ speed gt F0
...
<b>END</b>
</pre>
</div>

</div>
	
<aside class="notes">
Here, we have the invariants clause of the initial Event-B model using integers and their associated arithmetic operators. <br><br>

Now, The obtained model is adapted using the equivalent operators from the proposed theory. <br>
The obtained Event-B machine contains almost the same invariants and the same events. <br><br>

The only difference is the addition of the invariant concerning the well-definedness condition 
of the division operator used to formalise the speed of the moving object.	
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Revisiting our example II</h2>
		
<div class="r-stack">
<div class="eb-code fragment fade-out" data-fragment-index="0">
<pre id="eb">
<b>MACHINE</b> mch_integer_version
...
<b>EVENTS</b>
	...
	get_speed $\mathrel{\widehat=}$ 
		<i>any</i> p t
		<i>where</i>
			<u>@grd1:</u> p $\in$ $\mathbb N_1$ $\land$ p $>$ starting_position
			<u>@grd2:</u> t $\in$ $\mathbb N_1$ $\land$ t $>$ starting_time
		<i>then</i>
			<u>@act1:</u> distance_travelled $:=$ p $-$ starting_position
			<u>@act2:</u> measured_time $:=$ t $-$ starting_time
			<u>@act3:</u> speed $:=$ (p $-$ starting_position) $\div$ (t $-$ starting_time)
		<i>end</i>
<b>END</b>
</pre>	
</div>

<div class="eb-code fragment current-visible" data-fragment-index="0">
<pre id="eb">
<b>MACHINE</b> mch_floating_point_version
...
<b>EVENTS</b>
	...
	get_speed $\mathrel{\widehat=}$ 
		<i>any</i> p t
		<i>where</i>
			<u>@grd1:</u> p $\in$ PFLOAT_Type $\land$ p gt starting_position
			<u>@grd2:</u> t $\in$ PFLOAT_Type $\land$ t gt starting_time
		<i>then</i>
			<u>@act1:</u> distance_travelled $:=$ p minus starting_position
			<u>@act2:</u> measured_time $:=$ t minus starting_time
			<u>@act3:</u> speed $:=$ (p minus starting_position) div (t minus starting_time)
		<i>end</i>
<b>END</b>	
</pre>
</div>

<div class="eb-code fragment">
<pre id="eb">
<b>MACHINE</b> mch_floating_point_version
...
<b>EVENTS</b>
	...
	get_speed $\mathrel{\widehat=}$ 
		<i>any</i> p t
		<i>where</i>
			<u>@grd1:</u> p $\in$ PFLOAT_Type $\land$ p gt starting_position
			<u>@grd2:</u> t $\in$ PFLOAT_Type $\land$ t gt starting_time
			<span style="color: orangered;">@grd3: div_WD(p minus starting_position, t minus starting_time)</span>
		<i>then</i>
			<u>@act1:</u> distance_travelled $:=$ p minus starting_position
			<u>@act2:</u> measured_time $:=$ t minus starting_time
			<u>@act3:</u> speed $:=$ (p minus starting_position) div (t minus starting_time)
		<i>end</i>
<b>END</b>
</pre>
</div>
</div>


<aside class="notes">
The same thing for the "get_speed" event <br>
Here, we have also the initial event using integers and their associated arithmetic operators. <br><br>

Now, The obtained event is adapted using the equivalent operators from the floating-point numbers theory. <br><br>

As for the INVARIANTS clause, the only difference is the addition of the guard 
concerning the well-definedness condition of the division operator used to calculate the speed of the moving object.
</aside>
</section>	
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>generated and proven POs</h2>

	<div style="display: flex;">
		
		<img src="./img/fig2.png" alt="" height="auto" style="float: right; margin-bottom: 10px; margin-left: 10px; width: 30%;">
		<div  style="width: 70%;">
			<ul>
				<li>All generated POs have been proven.</li>
				<li class="fragment skip">The <span style="color: green;">$get\_speed/inv8/INV$</span> 
					PO becomes <span style="color: green;">&#10004;</span>.
					<ul id="fleche">
						<li>thanks to handling small values (<span class="listing">$]0..1[$</span>),</li>
						<li>and to the new <span class="listing">div</span> operator specification.</li>
					</ul>
				</li>
			</ul>
			<div id="green-block" class="fragment" style="margin-top: 80px; text-align: center; width: 75%;">
				<b>The floating-point numbers theory is more suitable than the basic integers of Event-B.</b>
			</div>
		</div>
	</div>
	<aside class="notes">
		From the model verification point of view, contrary to the initial model, all generated proof obligations have been proven. <br><br>

		The problem with the invariant linked to the integer division operator no longer arises. <br>
		The associated PO becomes green, and it has been proven using the interactive prover. <br><br>
		As we have said, the "@inv8" formalises the property specifying that if the value of the "distance_travelled" variable 
		is strictly positive, the "speed" variable must also be strictly positive. 
		Even if in the "get_speed" event, the value of the "distance_travelled" can 
		be less than that of "measured_time", the new value of the "speed" variable is never equal to zero because the value 
		of "distance_travelled"
		is also never equal to zero. <br>
		All this is possible thanks to the new division operator specification, 
		which acts on the floating-point numbers. 
		<br><br>

		This is one of the reasons that allow us to conclude that our floating-point numbers theory is more suitable 
		than the basic integers of Event-B in modelling hybrid systems and continuous behaviors.
	</aside>	
</section>	
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section id="ch5" name="Conclusion and future works">
	<aside class="notes">
		After this small conclusion, I will continue with the general conclusion.
	</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>Conclusion</h2>

	<ul>
		<li>Extending the <b>Event-B type-checking system</b> by an approach using <br>
			the <i>theory plugin</i>.</li>
		
		<li class="fragment skip">Development of a <b>floating point number theory</b> formalizing floating <br>
			point numbers.
			<ul id="fleche">
				<li>an extension of the <b>Event-B power operator</b>.</li>
				<li>an <b>abstract representation</b> of the <b>floating-point numbers</b>.</li>
				<li>a set of theorems and associated <b>rewrite</b> and <b>inference rules</b>.</li>
			</ul>
		</li>
	</ul>

<aside class="notes">
	In this work, we have proposed an approach using the theory plugin to extend the Event-B type-checking 
	system with the possibility of handling floating-point numbers. <br><br>

	We have developed a floating-point numbers theory that formalises a floating-point number using 
	an integer "significand", scaled by an integer "exponent" of a fixed "base" <br><br> 
	
	Our proposition includes an extension of the Event-B power operator to handle powers of ten more than 0 and 1. <br>
	We have proposed an abstract representation of the floating-point numbers to offer the possibility to refine the proposed 
	theory to any more concrete implementation. <br>
	And finally, the proposed theory contains a set of theorems and associated rewrite and inference rules that 
	can assist developers in the proof activity.
</aside>
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h2>future works</h2>
	<ul>
		<li>Refining the proposed theory to any <b>more concrete implementation</b><br> 
			(the <b>IEEE standard 754</b>, for example).</li>

		<li class="fragment skip">Developing a <b>more general theory</b> formalizing the standard units <br>
			of <i>measurement</i> defined by the <b>International System of Units</b> (<b>SI</b>).
			<ul id="fleche">
				<li>extends the <b>floating point number theory</b>.</li>
				<li>helpful in <b>modelling cyber-physical</b>/<b>hybrid</b> systems.</li>
			</ul>
		</li>
	</ul>
<aside class="notes">
For the next step of our work, we plan to refine the proposed theory to the IEEE standard 754 of floating-point numbers representation. <br><br>

Then, We consider the floating-point numbers theory the first step before developing a more general theory that will 
formalise the standard units of measurement defined by the International System of Units. <br>
I think that such theories will help many Event-B developers to model and verify cyber-physical systems. 
</aside>
	
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section data-transition="fade-in fade-out">
	<h1>Thank you</h1>
	<p>
		<a href="#">Back to the begin</a>
		- <a href="#/plan">Back to the outline</a>
	</p>
	<aside class="notes">
		Thank you very much for your attention. 
	</aside>	
</section>
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
		</div>
	</div>

	<script src="../resources/js/plan-en.js"></script>
	<script src="../reveal-js-framework/dist/reveal.js"></script>
	<script src="../reveal-js-framework/plugin/notes/notes.js"></script>
	<script src="../reveal-js-framework/plugin/math/math.js"></script>

	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			// Display presentation control arrows
			controls: true,
			// Display a presentation progress bar
			progress: true,

			// Vertical centering of slides
			center: true,
			// The "normal" size of the presentation, aspect ratio will
			// be preserved when the presentation is scaled to fit different
			// resolutions. Can be specified using percentage units.
			width: 1280,
			height: 720,

			// Add the current slide number to the URL hash so that reloading the
			// page/copying the URL will return you to the same slide
			hash: true,

			slideNumber: 'c/t',

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMath.MathJax3, RevealNotes]
		});

		Reveal.configure({ pdfSeparateFragments: false });
	</script>


</body>

</html>